# 新技术整合

标签（空格分隔）： 技术栈

---

## 1.WebAssembly
### 1.理论基础
- 代码运行快慢决定因素
  - 硬件层面：直接取决于生成的机器码所需时钟周期的总和
  - 编程语言层面：取决于编译后的产物在运行时有多少"动态决议"
  - "动态决议"：例如，弱类型语言比强类型语言慢，是因为编译时类型是不确定的，需要运行时进行额外的型别推导
- 前身asm.js：
  - 本质：Emscripten将C/C++代码转化成的js代码
  - 特点：不再支持除了浮点和整形之外的类型，内存的开辟和释放也需要代码手动进行处理
  - 运行更快原因：去掉大部分的自动GC机制，改成强类型语言，编译器能够更大程度地进行优化
- WebAssembly定义：
  - 编程：有一套完整的语义，但作为开发者并不需要去了解它，开发者依然可以继续使用自己熟悉的编程语言，由各个语言的编译器将其编译成Wasm格式后运行在浏览器内置的Wasm虚拟机中
  - 特性：一种可以在现代浏览器中运行的新型代码，一种低级的类似汇编的语言，具有紧凑的二进制格式，运行起来具有接近原生的性能
  - 地位：与HTML、CSS以及JavaScript并列的web领域第四类编程语言
- WebAssembly比asm.js要快的原因在于：
  - 体积更小：JavaScript 通过gzip压缩后已经可以节约很大一部分空间，但 WebAssembly 的二进制格式在被精心设计之后可以比gzip压缩后的 JavaScript 代码小10-20%左右
  - 解析更快：得益于其二进制的格式以及可以在多核CPU上进行并行解析，WebAssembly 解析速度比 JavaScript 快了一个数量级
  - 更好地利用CPU特性：可以利用更多CPU特性，其中例如：64位整数、加载/存储偏移量以及各种CPU指令。在这一部分，WebAssembly能比asm.js平均提速5%左右
  - 编译工具链的优化：WebAssembly的运行效率同时取决于两部分，第一个是生成代码的编译器，第二个是运行它的虚拟机。WebAssembly对其编译器进行了更多的优化，使用Binaryen编译器代替了Emscripten，这部分所带来的的速度提升大约在5%-7%
- WebAssembly与JavaScript运行性能详细对比：Wasm快10%到1000%都有可能，不同的测试环境下不可一概而论
- 正确使用WebAssembly的步骤为：
  - 从web应用中所有模块梳理出有性能瓶颈的地方：例如你的web应用里有视频上传、文件对比、视频编解码、游戏等模块，这些都是很适合用WebAssembly来实现的。相反，基础的网页交互功能并不适合用WebAssembly来实现
  - 进行简单的demo性能测试：看是否能达到预期的加速效果，如果加速效果并不明显，那么就不适合切换到Wasm
  - 确定用来编译成WebAssembly的源语言：目前主流的语言基本都是支持WebAssembly的，唯一不同的区别是其编译器的优化程度。C++、RUST其编译优化程度会更高，其他如PHP/GO/JS/Python等语言也可
  - 编码实现后导出.wasm文件：确定语言之后使用对应的编译器，源码为二进制代码，需尽量多打开debug选项
  - 编写JavaScript胶水代码加载.wasm模块：在最小可行版本的实现中，在 Web 上访问 WebAssembly 的唯一方法是通过显式的JavaScript API调用，而在ES6标准中，WebAssembly 也可以直接从`<script type='module'>`的HTML标签加载和运行
- WebAssembly SIMD：WebAssembly的一项特性，它允许在浏览器中高效地执行并行数据计算。SIMD是一种通过单条指令同时处理多个数据的计算模式，能显著加速需要处理大量数据的应用（如多媒体处理、科学计算、游戏等）


### 2.实际应用
- 应用场景
  - GooGle：可视化地球
  - Bilibili：视频编解码
  - Adobe：使用Emscripten将Photeshop的完整C++工程直接移植到了web端，而无需用JS重写。Emscripten 是一个功能齐全的工具链，它不仅可以帮你将 C++ 编译为 Wasm，还提供了一个转换层，可以将 POSIX API 调用转换为 Web API 调用，将 OpenGL 转换为 WebGL
  - Zoom：在线会议，将WebAssembly SIMD的能力引入了ZoomWeb。WebAssembly SIMD 提供了可移植、高性能的SIMD命令集，可用于目前绝大多数主流CPU架构。音视频编解码、图像处理这些都是SIMD的典型应用场景，ZoomWeb中虚拟背景的底层计算就是利用WebAssembly SIMD来实现的
  - FFmpeg：音视频处理，ffmpeg.wasm的意义就在于可以不再完全依赖浏览器的音视频能力，强大的几乎支持所有格式的音视频处理能力可以被移植到web端
- 应用领域
  - PC端的应用移植到web端，无需二次开发，保持多端代码一致性
  - 音视频处理这些高性能应用的场景，切换到WebAssembly确实能带来很大的性能提升
  - 后端微服务/无服务这一块，可以实现支持多语言的云函数之类的平台
- 开发工具
  - AssemblyScript：支持直接将TypeScript编译成WebAssembly
  - Emscripten：将其他的高级语言，编译成WebAssembly
  - WABT：WebAssembly在字节码和文本格式相互转换的一个工具，方便开发者去理解这个wasm
- React调用Wasm示例

```javascript
const fibonacciUrl = './fibonacci.wasm';
const {_fibonacci} = await this.getExportFunction(fibonacciUrl);

getExportFunction = async (url) => {
    const env = {
      memoryBase: 0,
      tableBase: 0,
      memory: new WebAssembly.Memory({
        initial: 256
      }),
      table: new WebAssembly.Table({
        initial: 2,
        element: 'anyfunc'
      })
    };
    const instance = await fetch(url).then((response) => {
      return response.arrayBuffer();
    }).then((bytes) => {
      return WebAssembly.instantiate(bytes, {env: env})
    }).then((instance) => {
      return instance.instance.exports;
    });
    return instance;
};
```


## 2.WebSocket
### 1.理论基础
- 核心作用
  - 实时双向通信：突破HTTP请求-响应模式的限制
  - 低延迟：建立连接后无需重复握手
  - 高效：相比HTTP轮询，减少不必要的数据传输
  - 持久连接：一次连接，长期使用
- 常见应用场景
  - 实时聊天应用
  - 实时数据监控/仪表盘
  - 多人协作编辑
  - 在线游戏
  - 实时通知系统
- 简单示例

```javascript
// 前端WebSocket实现聊天
const chatSocket = new WebSocket('wss://example.com/chat');

chatSocket.onopen = () => {
  console.log('WebSocket连接已建立');
  chatSocket.send(JSON.stringify({
    type: 'join',
    userId: 'user123'
  }));
};

chatSocket.onmessage = (event) => {
  const message = JSON.parse(event.data);
  if (message.type === 'chat') {
    appendMessage(message.sender, message.content);
  }
};

function sendMessage(content) {
  chatSocket.send(JSON.stringify({
    type: 'chat',
    content: content,
    sender: 'user123'
  }));
}
```
- 安全考虑
  - 使用WSS：始终使用wss://(WebSocket Secure)而非ws://
  - 输入验证：验证所有接收的数据
  - 速率限制：防止客户端发送过多消息
  - 认证授权：连接时发送认证令牌
```javascript
const socket = new WebSocket('wss://example.com');
socket.onopen = () => {
  socket.send(JSON.stringify({
    type: 'auth',
    token: 'your-auth-token'
  }));
};
```
- 性能优化
  - 消息压缩：特别是对于高频小消息
  - 批量更新：对高频更新进行节流和批量处理
  - 二进制数据传输
```javascript
// 发送二进制数据
socket.binaryType = 'arraybuffer';
socket.onmessage = (event) => {
  const data = new Uint8Array(event.data);
  // 处理二进制数据
};
```


### 2.使用nodejs搭建
- 使用原生ws库 + HTTPS

```javascript
const https = require('https');
const fs = require('fs');
const WebSocket = require('ws');

// 1. 准备SSL证书
const server = https.createServer({
  cert: fs.readFileSync('/path/to/cert.pem'),
  key: fs.readFileSync('/path/to/key.pem')
});

// 2. 创建WebSocket服务器
const wss = new WebSocket.Server({ server });

// 3. 处理WebSocket连接
wss.on('connection', (ws) => {
  console.log('新的客户端连接');
  
  ws.on('message', (message) => {
    console.log('收到消息:', message);
    // 广播给所有客户端
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
});

// 4. 启动服务器
server.listen(443, () => {
  console.log('WSS服务运行在 wss://localhost');
});
```
- 使用Express + express-ws库

```javascript
const express = require('express');
const expressWs = require('express-ws');
const https = require('https');
const fs = require('fs');

// 1. 创建Express应用
const app = express();
expressWs(app); // 启用WebSocket支持

// 2. 准备SSL证书
const server = https.createServer({
  cert: fs.readFileSync('/path/to/cert.pem'),
  key: fs.readFileSync('/path/to/key.pem')
}, app);

// 3. 定义WebSocket端点
app.ws('/chat', (ws, req) => {
  console.log('新的聊天连接');
  
  ws.on('message', (msg) => {
    console.log('收到消息:', msg);
    // 简单的回声
    ws.send(`服务器收到: ${msg}`);
  });
});

// 4. 启动服务器
server.listen(443, () => {
  console.log('Express WSS服务运行在 wss://localhost/chat');
});
```
- 完整示例

```javascript
const https = require('https');
const fs = require('fs');
const WebSocket = require('ws');
const path = require('path');

// 配置
const PORT = 443;
const SSL_CERT = path.join(__dirname, 'fullchain.pem');
const SSL_KEY = path.join(__dirname, 'privkey.pem');

// 创建HTTPS服务器
const server = https.createServer({
  cert: fs.readFileSync(SSL_CERT),
  key: fs.readFileSync(SSL_KEY),
  // 增强安全性配置
  minVersion: 'TLSv1.2',
  ciphers: [
    'ECDHE-ECDSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES256-GCM-SHA384',
    // ...其他安全加密套件
  ].join(':'),
  honorCipherOrder: true
});

// 创建WebSocket服务器
const wss = new WebSocket.Server({
  server,
  // 限制最大负载
  maxPayload: 1024 * 1024 // 1MB
});

// 连接管理
const clients = new Set();

wss.on('connection', (ws, req) => {
  console.log(`新的连接来自: ${req.socket.remoteAddress}`);
  clients.add(ws);
  
  // 心跳检测
  let isAlive = true;
  const heartbeatInterval = setInterval(() => {
    if (!isAlive) {
      ws.terminate();
      return;
    }
    isAlive = false;
    ws.ping();
  }, 30000);
  
  ws.on('pong', () => {
    isAlive = true;
  });
  
  // 消息处理
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      // 广播消息
      clients.forEach((client) => {
        if (client !== ws && client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            from: 'server',
            content: `用户消息: ${data.content}`
          }));
        }
      });
    } catch (err) {
      console.error('消息解析错误:', err);
    }
  });
  
  // 连接关闭
  ws.on('close', () => {
    console.log('连接关闭');
    clients.delete(ws);
    clearInterval(heartbeatInterval);
  });
  
  // 错误处理
  ws.on('error', (err) => {
    console.error('WebSocket错误:', err);
  });
});

// 启动服务器
server.listen(PORT, () => {
  console.log(`WSS服务运行在 wss://localhost:${PORT}`);
});

// 优雅关闭
process.on('SIGTERM', () => {
  console.log('正在关闭服务器...');
  wss.clients.forEach((client) => {
    client.close(1001, '服务器关闭');
  });
  server.close(() => {
    console.log('服务器已关闭');
    process.exit(0);
  });
});
```

### 3.获取SSL证书
- 自签名证书(开发环境)

```bash
# 生成私钥和自签名证书
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes`
```
- Let's Encrypt(生产环境推荐)

```bash
# 使用certbot获取免费证书
sudo apt-get install certbot
sudo certbot certonly --standalone -d yourdomain.com
```
- 云服务商提供的免费证书：如阿里云、腾讯云等都提供免费SSL证书


### 4.Nginx反向代理

```nginx
server {
    listen 443 ssl;
    server_name yourdomain.com;

    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;

    location /websocket {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```


## 3.Nginx
### 1.基本概念
- 正向代理与反向代理

|类型	|正向代理	|反向代理|
| -- | -- | -- |
|代理对象	|客户端	|服务器
|客户端感知	|知道代理存在	|不知道代理存在|
|主要用途	|突破访问限制、匿名访问	|负载均衡、安全防护、缓存加速|
|典型场景	|科学上网、公司内网代理	|网站接入、API网关|


- Nginx反向代理的核心功能
  - 请求转发：将客户端请求转发到后端服务器
  - 负载均衡：在多台服务器间分配流量
  - SSL终端：处理HTTPS加密/解密
  - 缓存加速：缓存静态内容减轻后端压力
  - 安全防护：隐藏后端服务器，防范DDoS攻击
  
- 原理图解
```text
客户端 → Nginx(反向代理) → 后端服务器(实际处理请求)
       ↑                ↑
       外部访问地址     内部服务器地址
```

- 典型代理配置

```nginx
server {
    listen 80;
    server_name example.com;
    root /var/www/html;  # 静态资源根目录
    index index.html;     # 默认入口文件
    
    location / {
        try_files $uri $uri/ /index.html;  # 单页应用路由处理
        proxy_pass http://backend_server;  # 转发到后端服务器
        proxy_set_header Host $host;      # 传递原始主机头
        proxy_set_header X-Real-IP $remote_addr;  # 传递客户端真实IP
    }
}

upstream backend_server {
    server 192.168.1.100:8080;  # 后端服务器地址
    server 192.168.1.101:8080;  # 可以定义多个实现负载均衡
}
```

### 2.核心指令详解
- 定义后端服务器地址
```nginx
location /api/ {
    proxy_pass http://backend_servers;
    # 注意：尾部有/时，会去除匹配的前缀
    # proxy_pass http://backend/;  # /api/foo → /foo
}
```
- 请求头处理
```nginx
proxy_set_header Host $host;             # 保留原始主机头
proxy_set_header X-Real-IP $remote_addr; # 客户端真实IP
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 代理链
```
- 超时控制
```nginx
proxy_connect_timeout 5s;    # 连接超时
proxy_send_timeout 10s;      # 发送超时
proxy_read_timeout 30s;      # 读取超时
```
- 缓冲与缓存
```nginx
proxy_buffering on;                  # 启用缓冲
proxy_buffer_size 4k;                # 缓冲区大小
proxy_buffers 8 16k;                 # 缓冲块数量及大小
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m inactive=60m;
proxy_cache my_cache;                # 启用缓存
```


### 3.实际应用场景
- 负载均衡
```nginx
upstream backend {
    least_conn;               # 最少连接算法
    server 10.0.0.1:80 weight=3;  # 权重
    server 10.0.0.2:80;
    server 10.0.0.3:80 backup;    # 备用服务器
}

server {
    location / {
        proxy_pass http://backend;
    }
}
```
- 动静分离
```nginx
server {
    location /static/ {
        root /var/www/static;  # 直接处理静态文件
        expires 30d;          # 设置缓存过期
    }
    
    location / {
        proxy_pass http://app_server;  # 动态请求转发
    }
    
    location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
        expires 30d;          # 缓存过期时间
        add_header Cache-Control "public, no-transform";
        access_log off;       # 关闭日志减少IO
    }
}
```
- API网关
```nginx
location /user-service/ {
    rewrite ^/user-service/(.*) /$1 break;  # URL重写
    proxy_pass http://user_service;
}

location /order-service/ {
    rewrite ^/order-service/(.*) /$1 break;
    proxy_pass http://order_service;
}
```
- 跨域处理
```nginx
location /api/ {
    add_header 'Access-Control-Allow-Origin' '$http_origin';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
    add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,Content-Type';
    add_header 'Access-Control-Allow-Credentials' 'true';
    
    if ($request_method = 'OPTIONS') {
        return 204;
    }
    
    proxy_pass http://api_server;
}
```
- 启用http/2
```nginx
server {
    listen 443 ssl http2;
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
}
```



### 4.性能优化技巧
- 连接池优化
```nginx
upstream backend {
    keepalive 32;  # 保持长连接
    server 10.0.0.1:8080;
}
```
- 缓冲区优化
```nginx
proxy_buffers 8 16k;
proxy_buffer_size 32k;
```
- 启用Gzip压缩
```nginx
gzip on;
gzip_types text/plain application/json;
```
- 缓存静态内容
```nginx
proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m inactive=60m;
location / {
    proxy_cache my_cache;
    proxy_cache_valid 200 302 10m;
}
```


### 5.安全配置
- 限制访问
```nginx
location /admin/ {
    allow 192.168.1.0/24;
    deny all;
    proxy_pass http://backend;
}
```
- 速率限制
```nginx
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

location /api/ {
    limit_req zone=api_limit burst=20;
    proxy_pass http://api_backend;
}
```
- 隐藏头部信息
```nginx
proxy_hide_header X-Powered-By;
server_tokens off;
```


### 6.常见问题排查
- 502 Bad Gateway
  - 检查后端服务是否运行
  - 检查Nginx错误日志：tail -f /var/log/nginx/error.log
  - 调整超时设置
- 413 Request Entity Too Large：`client_max_body_size 20M;  # 增加最大请求体大小`
- WebSocket连接问题
  - 确保配置了Upgrade和Connection头
  - 检查防火墙设置